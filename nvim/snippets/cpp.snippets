snippet dsu
  struct DSU {
  private:
    int _n;
    std::vector<int> parent, size;

  public:
    DSU() : _n(0) {}
    DSU(int n) : _n(n) {
      parent.resize(_n, -1);
      size.resize(_n, -1);
    }

    void add(int x) {
      parent[x] = x;
      size[x] = 1;
    }

    int leader(int x) {
      assert(0 <= x && x < _n);

      if (parent[x] == x)
        return x;

      return parent[x] = leader(parent[x]);
    }

    int merge(int a, int b) {
      assert(0 <= a && a < _n);
      assert(0 <= b && b < _n);
      int x = leader(a), y = leader(b);

      if (x == y)
        return x;

      if (parent[x] < parent[y])
        std::swap(x, y);

      size[x] += size[y];
      parent[y] = x;

      return x;
    }

    bool same(int a, int b) {
      assert(0 <= a && a < _n);
      assert(0 <= b && b < _n);
      return leader(a) == leader(b);
    }
  };

snippet encoding
  template <typename T, typename T_iterable> std::vector<std::pair<T, int>> run_length_encoding(T_iterable &items) {
    std::vector<std::pair<T, int>> encoding;
    T character = items[0];
    int count = 0;

    for (char &item : items) {
      if (character == item) {
        count++;
      } else {
        encoding.emplace_back(character, count);
        count = 1;
        character = item;
      }
    }

    encoding.emplace_back(character, count);

    return encoding;
  }

snippet fenwick-tree
  struct fenwick_tree {
    std::vector<int> tree;
    int n;

    fenwick_tree(int n) {
      this->n = n;
      tree.assign(n, 0);
    }

    fenwick_tree(std::vector<int> const &a) : fenwick_tree(a.size()) {
      for (size_t i = 0; i < a.size(); i++)
        update(i, a[i]);
    }

    int query(int index) {
      int result = 0;

      while (index > 0) {
        result += tree[index];
        index -= index & (-index);
      }

      return result;
    }

    void update(int index, int delta) {
      while (index < n) {
        tree[index] += delta;
        index = index | (index + 1);
      }
    }

    void update(int low, int high, int delta) {
      update(low, delta);
      update(high + 1, -delta);
    }
  };

snippet dijkstra
  struct Graph {
    const int INF = int(1e9); // NOTE: set INF for your convenience
    std::vector<std::vector<std::pair<int, int>>> edges;
    std::vector<int> dist;

    Graph(int size) {
      edges.resize(size);
      dist.resize(size, INF);
    }

    void add_edge(int u, int v, int w) {
      edges[u].push_back(std::make_pair(w, v));
    }

    void dijkstra(int src) {
      std::set<std::pair<int, int>> queue;
      queue.insert(std::make_pair(0, src));
      dist[src] = 0;

      while (!queue.empty()) {
        std::pair<int, int> node = *queue.begin();
        queue.erase(queue.begin());

        for (std::pair<int, int> child : edges[node.second]) {
          int distance = dist[node.second] + child.first;

          if (distance < dist[child.second]) {
            dist[child.second] = distance;
            queue.insert(child);
          }
        }
      }
    }
  };

snippet kadane
  int max_subarray_sum(std::vector<int> &arr) {
    int max_so_far = INT_MIN, max_ending_here = 0;

    for (int i = 0; i < (int)arr.size(); i++) {
      max_ending_here = max_ending_here + arr[i];
      max_so_far = std::max(max_so_far, max_ending_here);
      max_ending_here = std::max(max_ending_here, 0);
    }

    return max_so_far;
  }

snippet kadane
  int64_t max_sum_with_k(std::vector<int64_t> &container, int64_t k) {
    int n = (int)container.size();
    std::vector<int> maxsum(n);
    int currmax = container[0];
    maxsum[0] = container[0];

    for (int i = 1; i < n; i++) {
      currmax = std::max(container[i], currmax + container[i]);
      maxsum[i] = currmax;
    }

    int sum_k = accumulate(container.begin(), container.begin() + k, int64_t(0));
    int result = sum_k;

    for (int i = k; i < n; i++) {
      sum_k += container[i] - container[i - k];
      result = std::max({result, sum_k, sum_k + maxsum[i - k]});
    }

    return result;
  }

snippet mint
  template <long long MOD> class MINT {
  private:
    long long value;

  public:
    MINT() : value(0) {}

    MINT(long long v) {
      value = v % MOD;

      if (value < 0)
        value += MOD;
    }

    MINT pow(long long exponent) const {
      MINT result = 1, base = *this;

      while (exponent > 0) {
        if (exponent & 1)
          result *= base;

        base *= base;
        exponent >>= 1;
      }

      return result;
    }

    MINT inv() const { return pow(MOD - 2); }

    operator long long() const { return value; }

    MINT &operator+=(const MINT &other) {
      value += other.value;

      if (value >= MOD)
        value -= MOD;

      return *this;
    }

    MINT &operator-=(const MINT &other) {
      value -= other.value;

      if (value < 0)
        value += MOD;

      return *this;
    }

    MINT &operator*=(const MINT &other) {
      value = (value * other.value) % MOD;
      return *this;
    }

    MINT &operator/=(const MINT &other) {
      *this *= other.inv();
      return *this;
    }

    friend MINT operator+(MINT a, const long long &b) {
      return MINT((a.value + (b % MOD) + MOD) % MOD);
    }

    friend MINT operator-(MINT a, const long long &b) {
      return MINT((a.value - (b % MOD) + MOD) % MOD);
    }

    friend MINT operator*(MINT a, const long long &b) {
      return MINT((a.value * (b % MOD)) % MOD);
    }

    friend MINT operator/(MINT a, const long long &b) {
      return MINT((a.value * MINT(b).inv().value) % MOD);
    }

    friend MINT operator+(MINT a, const MINT &b) {
      return MINT((a.value + b.value) % MOD);
    }

    friend MINT operator-(MINT a, const MINT &b) {
      return MINT((a.value - b.value + MOD) % MOD);
    }

    friend MINT operator*(MINT a, const MINT &b) {
      return MINT((a.value * b.value) % MOD);
    }

    friend MINT operator/(MINT a, const MINT &b) {
      return MINT((a.value * b.inv().value) % MOD);
    }

    friend std::ostream &operator<<(std::ostream &os, const MINT &mi) {
      return os << mi.value;
    }

    friend std::istream &operator>>(std::istream &is, MINT &mi) {
      long long x;
      is >> x;
      mi = MINT(x);
      return is;
    }
  };

  const long long MOD = 1e9 + 7;
  using mint = MINT<MOD>;

snippet ordered-set
  #include <ext/pb_ds/assoc_container.hpp>
  #include <ext/pb_ds/tree_policy.hpp>
  using namespace __gnu_pbds;
  template <typename T>
  using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;

snippet segment-tree
  template <typename T> struct segment_tree {
  public:
    segment_tree(std::vector<T> &data) {
      N = data.size();
      tree.resize(N * 4);
      lazy.resize(N * 4, 0);
      identity = 0;
      operation = [](T a, T b) -> T { return a + b; };
      apply_update = [](T a, T b, int len) -> T { return a + b * len; };
      build(data, 0, 0, N - 1);
    }

    segment_tree(std::vector<T> &data, T identity,
                 std::function<T(T, T)> operation,
                 std::function<T(T, T, int)> apply_update) {
      N = data.size();
      tree.resize(N * 4);
      lazy.resize(N * 4, identity);
      this->identity = identity;
      this->operation = operation;
      this->apply_update = apply_update;
      build(data, 0, 0, N - 1);
    }

    T query(int L, int R) { return _query(0, 0, N - 1, L, R); }

    void update(int L, int R, T update_value) {
      _update(0, 0, N - 1, L, R, update_value);
    }

  private:
    int N;
    T identity;
    std::vector<T> tree, lazy;
    std::function<T(T, T)> operation;
    std::function<T(T, T, int)> apply_update;

    void build(std::vector<T> &data, int node, int begin, int end) {
      if (begin == end) {
        tree[node] = data[begin];
      } else {
        int mid = begin + (end - begin) / 2;
        build(data, 2 * node + 1, begin, mid);
        build(data, 2 * node + 2, mid + 1, end);
        tree[node] = operation(tree[2 * node + 1], tree[2 * node + 2]);
      }
    }

    void propagate(int node, int begin, int end) {
      if (lazy[node] != identity) {
        tree[node] = apply_update(tree[node], lazy[node], end - begin + 1);

        if (begin != end) {
          lazy[2 * node + 1] = operation(lazy[2 * node + 1], lazy[node]);
          lazy[2 * node + 2] = operation(lazy[2 * node + 2], lazy[node]);
        }

        lazy[node] = identity;
      }
    }

    T _query(int node, int begin, int end, int L, int R) {
      propagate(node, begin, end);

      if (R < begin || L > end)
        return identity;

      if (L <= begin && end <= R)
        return tree[node];

      int mid = begin + (end - begin) / 2;
      T sub_L = _query(2 * node + 1, begin, mid, L, R);
      T sub_R = _query(2 * node + 2, mid + 1, end, L, R);
      return operation(sub_L, sub_R);
    }

    void _update(int node, int begin, int end, int L, int R, T update_value) {
      propagate(node, begin, end);

      if (R < begin || L > end)
        return;

      if (L <= begin && end <= R) {
        tree[node] = apply_update(tree[node], update_value, end - begin + 1);

        if (begin != end) {
          lazy[2 * node + 1] = operation(lazy[2 * node + 1], update_value);
          lazy[2 * node + 2] = operation(lazy[2 * node + 2], update_value);
        }

        return;
      }

      int mid = begin + (end - begin) / 2;
      _update(2 * node + 1, begin, mid, L, R, update_value);
      _update(2 * node + 2, mid + 1, end, L, R, update_value);
      tree[node] = operation(tree[2 * node + 1], tree[2 * node + 2]);
    }
  };

snippet segment-tree
  template <typename T> struct segment_tree {
  public:
    segment_tree(std::vector<T> &data) {
      int N = data.size();
      tree.resize(N * 4);
      identity = 0;
      operation = [](T a, T b) { return a + b; };
      build(data, 0, 0, N - 1);
    }

    segment_tree(std::vector<T> &data, T identity,
                 std::function<T(T, T)> operation) {
      N = data.size();
      tree.resize(N * 4);
      this->identity = identity;
      this->operation = operation;
      build(data, 0, 0, N - 1);
    }

    T query(int L, int R) { return _query(0, 0, N - 1, L, R); }

    void update(int index, T updated_value) {
      _update(0, 0, N - 1, index, updated_value);
    }

  private:
    int N;
    T identity;
    std::vector<T> tree;
    std::function<T(T, T)> operation;

    void build(std::vector<T> &data, int node, int begin, int end) {
      if (begin == end) {
        tree[node] = data[begin];
      } else {
        int mid = begin + (end - begin) / 2;
        build(data, 2 * node + 1, begin, mid);
        build(data, 2 * node + 2, mid + 1, end);
        tree[node] = operation(tree[2 * node + 1], tree[2 * node + 2]);
      }
    }

    T _query(int node, int begin, int end, int L, int R) {
      if (R < begin || L > end)
        return identity;

      if (L <= begin && end <= R)
        return tree[node];

      int mid = begin + (end - begin) / 2;
      T sub_L = _query(2 * node + 1, begin, mid, L, R);
      T sub_R = _query(2 * node + 2, mid + 1, end, L, R);
      return operation(sub_L, sub_R);
    }

    void _update(int node, int begin, int end, int index, T updated_value) {
      if (begin == end) {
        tree[node] = updated_value;
      } else {
        int mid = begin + (end - begin) / 2;

        if (index <= mid)
          _update(2 * node + 1, begin, mid, index, updated_value);
        else
          _update(2 * node + 2, mid + 1, end, index, updated_value);

        tree[node] = operation(tree[2 * node + 1], tree[2 * node + 2]);
      }
    }
  };

snippet sieve
  const int N = int(100);
  std::vector<bool> is_prime;
  std::vector<int> primes;

  void sieve() {
    is_prime.assign(N + 1, true);

    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= N; i++) {
      for (int j = 2; i * j <= N; j++) {
        is_prime[i * j] = false;
      }
    }

    for (int i = 2; i <= N; i++)
      if (is_prime[i] == true)
        primes.push_back(i);
  }

snippet main
  #include <bits/stdc++.h>
  using namespace std;

  template<typename T1, typename T2>
  ostream& operator<<(ostream &os, const pair<T1, T2> &p) {
    os << "(" << p.first << ", " << p.second << ")";
    return os;
  }

  template<typename T>
  ostream& operator<<(ostream &os, const vector<T> &v) {
    os << "[";
    for (int i = 0; i < v.size(); i++) {
      if (i > 0) os << ", ";
      os << v[i];
    }
    os << "]";
    return os;
  }

  template<typename T>
  ostream& operator<<(ostream &os, const set<T> &s) {
    os << "{";
    for (auto it = s.begin(); it != s.end(); ++it) {
      if (it != s.begin()) os << ", ";
      os << *it;
    }
    os << "}";
    return os;
  }

  template<typename K, typename V>
  ostream& operator<<(ostream &os, const map<K, V> &m) {
    os << "{";
    for (auto it = m.begin(); it != m.end(); ++it) {
      if (it != m.begin()) os << ", ";
      os << it->first << ": " << it->second;
    }
    os << "}";
    return os;
  }

  template<typename T>
  void debug_out(T val) {
    cerr << val;
  }

  template<typename T, typename... Args>
  void debug_out(T val, Args... args) {
    cerr << val << " ";
    debug_out(args...);
  }

  #define dbg(...) cerr << "[" << #__VA_ARGS__ << "]: "; debug_out(__VA_ARGS__); cerr << endl;
  #define ll int64_t
  #define all(x) (x).begin(), (x).end()

  const char nl = '\n';

  void testcase() {
    $1
  }

  int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin >> t;
    for (int i = 1; i <= t; i++) {
      // cout << "Case #" << i << ": ";
      testcase();
    }
    return 0;
  }

snippet main
  #include <bits/stdc++.h>
  using namespace std;

  template<typename T1, typename T2>
  ostream& operator<<(ostream &os, const pair<T1, T2> &p) {
    os << "(" << p.first << ", " << p.second << ")";
    return os;
  }

  template<typename T>
  ostream& operator<<(ostream &os, const vector<T> &v) {
    os << "[";
    for (int i = 0; i < v.size(); i++) {
      if (i > 0) os << ", ";
      os << v[i];
    }
    os << "]";
    return os;
  }

  template<typename T>
  ostream& operator<<(ostream &os, const set<T> &s) {
    os << "{";
    for (auto it = s.begin(); it != s.end(); ++it) {
      if (it != s.begin()) os << ", ";
      os << *it;
    }
    os << "}";
    return os;
  }

  template<typename K, typename V>
  ostream& operator<<(ostream &os, const map<K, V> &m) {
    os << "{";
    for (auto it = m.begin(); it != m.end(); ++it) {
      if (it != m.begin()) os << ", ";
      os << it->first << ": " << it->second;
    }
    os << "}";
    return os;
  }

  template<typename T>
  void debug_out(T val) {
    cerr << val;
  }

  template<typename T, typename... Args>
  void debug_out(T val, Args... args) {
    cerr << val << " ";
    debug_out(args...);
  }

  #define dbg(...) cerr << "[" << #__VA_ARGS__ << "]: "; debug_out(__VA_ARGS__); cerr << endl;
  #define ll int64_t
  #define all(x) (x).begin(), (x).end()

  const char nl = '\n';

  int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    $1

    return 0;
  }

snippet beginend
	$1.begin(), $1.end()
snippet gen
  #include <bits/stdc++.h>
  using namespace std;
  
  #define uid(low, high)  uniform_int_distribution<>(low, high)(rng)
  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
  
  void print(){cout << "\n";}template<typename T, typename...types> void print(const T& first, const types&...args) {cout << first << " "; print(args...);}
  
  int main() {
    $1
    return 0;
  }
